// Script is generated by AI (gemini-3-pro), code-style and boilerplate reflects that...
import fetch from "node-fetch";
import {
  Record as RuntypesRecord,
  String,
  Array,
  Number,
  Literal,
  Static,
} from "runtypes";
import fs from "fs";

const TALLINN_API_ENDPOINT =
  "https://gis.tallinn.ee/arcgis/rest/services/parkimine/MapServer/6/query?where=1%3D1&outFields=*&f=geojson";

const PROVIDER_ID = 10;

const FeatureRuntype = RuntypesRecord({
  type: Literal("Feature"),
  id: Number,
  geometry: RuntypesRecord({
    type: Literal("Polygon").Or(Literal("MultiPolygon")),
    coordinates: Array(Array(Array(Array(Number)))),
  }).Or(
    RuntypesRecord({
      type: Literal("Polygon"),
      coordinates: Array(Array(Array(Number))),
    })
  ),
  properties: RuntypesRecord({
    nimetus: String,
    tasu: String.Or(Number),
    markused: String,
    uhik: Number.Or(String).optional(),
  }),
});

const GeoJSONRuntype = RuntypesRecord({
  type: Literal("FeatureCollection"),
  features: Array(FeatureRuntype),
});

type Feature = Static<typeof FeatureRuntype>;

function getRegions(geometry: Feature["geometry"]) {
  if (geometry.type === "Polygon") {
    const coords = (geometry as any).coordinates[0] as number[][] | undefined;
    if (!coords) return [];
    return [{ points: coords.map((c) => [c[1], c[0]] as [number, number]) }];
  } else if (geometry.type === "MultiPolygon") {
    const polys = (geometry as any).coordinates as number[][][][] | undefined;
    if (!polys) return [];
    return polys.flatMap((poly) => {
      const ring = poly[0];
      if (!ring) return [];
      return [{ points: ring.map((c) => [c[1], c[0]] as [number, number]) }];
    });
  }
  return [];
}

function deriveCode(nimetus: string): string {
  switch (nimetus.trim()) {
    case "Vanalinna parkimisala":
      return "VANALINN15";
    case "Südalinna parkimisala":
      return "SÜDALINN15";
    case "Kesklinna parkimisala":
      return "KESKLINN15";
    case "Pirita parkimisala":
      return "PIRITA15";
    default:
      return nimetus;
  }
}

function parseMarkused(markused: string): any[] {
  const parts = markused.split("//").map((s) => s.trim());
  let targetText = parts[0] || "";

  if (parts.length > 1 && parts[1]) {
    const p1 = parts[1];
    if (p1 && p1.match(/Paid parking|Mon|Tue|Wed|Thu|Fri|Sat|Sun/i)) {
      targetText = p1;
    }
  }

  const priceMatch = targetText.match(/(\d+[.,]\d+)\s*€\/min/);
  let pricePerMinute = 0;
  if (priceMatch && priceMatch[1]) {
    pricePerMinute = parseFloat(priceMatch[1].replace(",", "."));
  }

  const priceInCents = Math.round(pricePerMinute * 100);
  const pricePerHour = priceInCents * 60;

  const tariffs: any[] = [];

  if (
    targetText.match(/May|Jun|Jul|Aug|Sep/i) &&
    targetText.match(/\d{1,2}\.?\s*(May|Jun|Jul|Aug|Sep)/i)
  ) {
    const hours = extractHours(targetText);
    if (hours) {
      tariffs.push({
        days: [1, 2, 3, 4, 5, 6, 7],
        start: hours.start,
        end: hours.end,
        periods: { "60": priceInCents, "3600": pricePerHour },
      });
    }
    return tariffs;
  }

  if (
    targetText.match(/twenty-four hours|24h|24\/7/i) ||
    targetText.includes("ööpäevaringselt")
  ) {
    tariffs.push({
      days: [1, 2, 3, 4, 5, 6, 7],
      periods: { "60": priceInCents, "3600": pricePerHour },
    });
    return tariffs;
  }

  const segments = targetText.split(/,|\./).map((s) => s.trim());

  for (const segment of segments) {
    if (!segment) continue;
    const hours = extractHours(segment);
    if (hours) {
      const days = extractDays(segment);
      if (days.length > 0) {
        tariffs.push({
          days: days,
          start: hours.start,
          end: hours.end,
          periods: { "60": priceInCents, "3600": pricePerHour },
        });
      }
    }
  }

  if (tariffs.length === 0 && priceInCents > 0) {
    if (
      targetText.toLowerCase().includes("paid parking") ||
      targetText.toLowerCase().includes("tasuline")
    ) {
      tariffs.push({
        days: [1, 2, 3, 4, 5, 6, 7],
        periods: { "60": priceInCents, "3600": pricePerHour },
      });
    }
  }

  return tariffs;
}

function extractHours(text: string): { start: number; end: number } | null {
  const rangeMatch = text.match(/(\d{1,2}):(\d{2})\s*-\s*(\d{1,2}):(\d{2})/);
  if (
    rangeMatch &&
    rangeMatch[1] &&
    rangeMatch[2] &&
    rangeMatch[3] &&
    rangeMatch[4]
  ) {
    return {
      start: parseInt(rangeMatch[1]) * 3600 + parseInt(rangeMatch[2]) * 60,
      end: parseInt(rangeMatch[3]) * 3600 + parseInt(rangeMatch[4]) * 60,
    };
  }

  const ampmMatch = text.match(/(\d{1,2})(AM|PM)\s*(to|-)\s*(\d{1,2})(AM|PM)/i);
  if (
    ampmMatch &&
    ampmMatch[1] &&
    ampmMatch[2] &&
    ampmMatch[4] &&
    ampmMatch[5]
  ) {
    let startH = parseInt(ampmMatch[1]);
    if (ampmMatch[2].toUpperCase() === "PM" && startH < 12) startH += 12;
    if (ampmMatch[2].toUpperCase() === "AM" && startH === 12) startH = 0;

    let endH = parseInt(ampmMatch[4]);
    if (ampmMatch[5].toUpperCase() === "PM" && endH < 12) endH += 12;
    if (ampmMatch[5].toUpperCase() === "AM" && endH === 12) endH = 0;

    return {
      start: startH * 3600,
      end: endH * 3600,
    };
  }
  return null;
}

function extractDays(text: string): number[] {
  const days: number[] = [];
  const rangeMatch = text.match(
    /(Mon|Tue|Wed|Thu|Fri|Sat|Sun|E|T|K|N|R|L|P)\s*-\s*(Mon|Tue|Wed|Thu|Fri|Sat|Sun|E|T|K|N|R|L|P)/i
  );
  if (rangeMatch && rangeMatch[1] && rangeMatch[2]) {
    const start = dayToInt(rangeMatch[1]);
    const end = dayToInt(rangeMatch[2]);
    if (start !== null && end !== null) {
      for (let i = start; i <= end; i++) days.push(i);
    }
    return days;
  }

  const words = text.split(/\s+/);
  for (const w of words) {
    const d = dayToInt(w);
    if (d !== null) days.push(d);
  }

  return days;
}

function dayToInt(d: string): number | null {
  const norm = d.toUpperCase().replace(/[.,]/g, "");
  if (["MON", "E"].includes(norm)) return 1;
  if (["TUE", "T"].includes(norm)) return 2;
  if (["WED", "K"].includes(norm)) return 3;
  if (["THU", "N"].includes(norm)) return 4;
  if (["FRI", "R"].includes(norm)) return 5;
  if (["SAT", "L"].includes(norm)) return 6;
  if (["SUN", "P"].includes(norm)) return 7;
  return null;
}

async function main() {
  const response = await fetch(TALLINN_API_ENDPOINT);
  const json = await response.json();
  const geojson = GeoJSONRuntype.check(json);

  const featuresWithCode = geojson.features.map((f) => ({
    feature: f,
    code: deriveCode(f.properties.nimetus),
  }));

  const results: any[] = [];

  for (const item of featuresWithCode) {
    const { feature, code } = item;
    const props = feature.properties;
    // Note: feature might be a Turf feature now which has similar structure but might need casting if strictly typed
    const regions = getRegions(feature.geometry as any);
    const tariffs = parseMarkused(props.markused);

    if (tariffs.length === 0) {
      let price = 0;
      if (typeof props.tasu === "string") {
        price = parseFloat(props.tasu.replace(",", "."));
      } else if (typeof props.tasu === "number") {
        price = props.tasu;
      }

      if (price > 0) {
        const pricePerMinuteInCents = Math.round(price * 100);
        const pricePerHourInCents = pricePerMinuteInCents * 60;
        tariffs.push({
          days: [1, 2, 3, 4, 5, 6, 7],
          periods: { "60": pricePerMinuteInCents, "3600": pricePerHourInCents },
        });
      }
    }

    if (code.endsWith("15")) {
      tariffs.forEach((t) => {
        t["free-period"] = 15 * 60;
      });
    }

    results.push({
      "beacon-minor": (feature as any).id,
      provider: PROVIDER_ID,
      code: code,
      regions: regions,
      tariffs: tariffs,
    });
  }

  const holeCodes = ["VANALINN15", "SÜDALINN15"];
  const holeRegions = results
    .filter((r) => holeCodes.includes(r.code))
    .flatMap((r) => r.regions);

  results
    .filter((r) => r.code === "KESKLINN15")
    .forEach((r) => {
      r.regions.forEach((region: any) => {
        region["interior-regions"] = holeRegions;
      });
    });

  return results;
}

main()
  .then((result) =>
    fs.writeFileSync("tallinn.json", JSON.stringify(result, null, 2))
  )
  .catch(console.error);
